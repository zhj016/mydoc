#插入－希尔排序

##基本思想：

先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。


我们简单处理增量序列：增量序列d = {n/2 ,n/4, n/8 .....1} n为要排序数的个数

	
	
	void print(int a[], int n ,int i){  
	    cout<<i <<":";  
	    for(int j= 0; j<8; j++){  
	        cout<<a[j] <<" ";  
	    }  
	    cout<<endl;  
	}  
	/** 
	 * 直接插入排序的一般形式 
	 * 
	 * @param int dk 缩小增量，如果是直接插入排序，dk=1 
	 * 
	 */  
	  
	void ShellInsertSort(int a[], int n, int dk)  
	{  
	    for(int i= dk; i<n; ++i){  
	        if(a[i] < a[i-dk]){          //若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入  
	            int j = i-dk;     
	            int x = a[i];           //复制为哨兵，即存储待排序元素  
	            a[i] = a[i-dk];         //首先后移一个元素  
	            while(x < a[j]){     //查找在有序表的插入位置  
	                a[j+dk] = a[j];  
	                j -= dk;             //元素后移  
	            }  
	            a[j+dk] = x;            //插入到正确位置  
	        }  
	        print(a, n,i );  
	    }  
	      
	}  
	  
	/** 
	 * 先按增量d（n/2,n为要排序数的个数进行希尔排序 
	 * 
	 */  
	void shellSort(int a[], int n){  
	  
	    int dk = n/2;  
	    while( dk >= 1  ){  
	        ShellInsertSort(a, n, dk);  
	        dk = dk/2;  
	    }  
	}  
	int main(){  
	    int a[8] = {3,1,5,7,2,4,9,6};  
	    //ShellInsertSort(a,8,1); //直接插入排序  
	    shellSort(a,8);           //希尔插入排序  
	    print(a,8,8);  
	}  
	
希尔排序时效分析很难，关键码的比较次数与记录移动次数依赖于增量因子序列d的选取，特定情况下可以准确估算出关键码的比较次数和记录的移动次数。目前还没有人给出选取最好的增量因子序列的方法。增量因子序列可以有各种取法，有取奇数的，也有取质数的，但需要注意：增量因子中除1 外没有公因子，且最后一个增量因子必须为1。希尔排序方法是一个不稳定的排序方法。